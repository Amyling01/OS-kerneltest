#!/usr/bin/expect -f 
# Copyright 1992-2000, 2007-2012 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This file was written by Fred Fish. (fnf@cygnus.com)

source ../lib/gdb_proc.exp
global target_dir
global GRET;
set GRET 0;
global ARGC;
global GDB_TOOL_DIR
set ARGC $argc
global GDBPROMPT
global gdb_prompt
global target_ip
global target_prompt
global inferior_exited_re

spawn ssh root@$target_ip
expect {
    -timeout 2
    -re "$target_prompt*" {}
timeout {
        send_user "\n*****error: ssh root@$target_ip failed*****\n"
        set GRET [expr $GRET + 1]
        exit 1
    }
}

set target_prompt "/tmp/for_gdb_test/base"
gdb_test "cd /tmp/for_gdb_test/base" "$target_prompt"
#if $tracelevel then {
#	strace $tracelevel
#}


# are we on a target board
#if ![isnative] then {
#    return
#}

set testfile "coremaker"
set srcfile ${testfile}.c
set binfile ${testfile}
#if  { [gdb_compile "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
#     untested corefile.exp
#     return -1
#}

# Create and source the file that provides information about the compiler
# used to compile the test case.
#if [get_compiler_info ${binfile}] {
#    return -1;
#}

#set corefile [core_find $binfile {coremmap.data}]
#if {$corefile == ""} {
#    return 0
#}

gdb_test "ulimit -c unlimited" "$target_prompt"
gdb_test "./$binfile" "$target_prompt"
# Test that we can simply startup with a "-core=$corefile" command line arg
# and recognize that the core file is a valid, usable core file.
# To do this, we must shutdown the currently running gdb and restart
# with the -core args.  We can't use gdb_start because it looks for
# the first gdb prompt, and the message we are looking for occurs
# before the first prompt.
#
# Another problem is that on some systems (solaris for example), there
# is apparently a limit on the length of a fully specified path to 
# the coremaker executable, at about 80 chars.  For this case, consider
# it a pass, but note that the program name is bad.

#            gdb_exit
#if $verbose>1 then {
#    send_user "Spawning $GDB $INTERNAL_GDBFLAGS $GDBFLAGS -core=$corefile\n"
#}

set corefile "core"
#verbose "Timeout is now $timeout seconds" 2
send "'$GDB_TOOL_DIR'gdb -core=$corefile\n"
expect {
    -re "Core was generated by .*coremaker.*\#0  .*\(\).*$gdb_prompt" {
#	pass "args: -core=[file tail $corefile]"
    }
    -re "Core was generated by .*\#0  .*\(\).*$gdb_prompt" {
#	pass "args: -core=[file tail $corefile] (with bad program name)"
    }
    timeout 		{ 
        send_user "(timeout) starting with -core" 
        set GRET [expr $GRET + 1]
    }
}


#
# Test that startup with both an executable file and -core argument.
# See previous comments above, they are still applicable.
#
gdb_exit

#if $verbose>1 then {
#    send_user "Spawning $GDB $INTERNAL_GDBFLAGS $GDBFLAGS $binfile -core=$corefile\n"
#}


send "'$GDB_TOOL_DIR'gdb $binfile -core=$corefile\n"
expect {
    -re "Core was generated by .*coremaker.*\#0  .*\(\).*$gdb_prompt" {
#	pass "args: execfile -core=[file tail $corefile]"
    }
    -re "Core was generated by .*\#0  .*\(\).*$gdb_prompt" {
#	pass "args: execfile -core=[file tail $corefile] (with bad program name)"
    }
    timeout 		{ 
        send_user "(timeout) starting with -core"
        set GRET [expr $GRET + 1]
    }
}

gdb_exit

# Now restart normally.

#         gdb_start
#gdb_reinitialize_dir $srcdir/$subdir
#gdb_load ${binfile}
gdb_test "'$GDB_TOOL_DIR'gdb $binfile" "$gdb_prompt"

# Test basic corefile recognition via core-file command.

send "core-file $corefile\n"
expect {
    -re ".* program is being debugged already.*y or n." {
	# gdb_load may connect us to a gdbserver.
	send "y\n"
	exp_continue;
    }
    -re "Core was generated by .*coremaker.*\r\n\#0  .*\(\).*$gdb_prompt" {
#	pass "core-file command"
    }
    -re "Core was generated by .*\r\n\#0  .*\(\).*$gdb_prompt" {
#	pass "core-file command (with bad program name)"
    }
    timeout  	{ 
        send_user "(timeout) core-file $corefile"
        set GRET [expr $GRET + 1]
    }
}

# Test correct mapping of corefile sections by printing some variables.

gdb_test "print coremaker_data" "\\\$$decimal = 202"
gdb_test "print coremaker_bss" "\\\$$decimal = 10"
gdb_test "print coremaker_ro" "\\\$$decimal = 201"

gdb_test "print func2::coremaker_local" "\\\$$decimal = \\{0, 1, 2, 3, 4\\}"

# Somehow we better test the ability to read the registers out of the core
# file correctly.  I don't think the other tests do this.

gdb_test "bt" "abort.*func2.*func1.*main.*" "backtrace in corefile.exp"
gdb_test "up" "#\[0-9\]* *\[0-9xa-fH'\]* in .* \\(.*\\).*" "up in corefile.exp"

# Test ability to read mmap'd data

gdb_test "x/8bd buf1" ".*:.*0.*1.*2.*3.*4.*5.*6.*7" "accessing original mmap data in core file"
#setup_xfail "*-*-sunos*" "*-*-ultrix*" "*-*-aix*"
set test "accessing mmapped data in core file"
gdb_test "x/8bd buf2" ".*:.*0.*1.*2.*3.*4.*5.*6.*7.*$gdb_prompt" 

gdb_exit
# test reinit_frame_cache

gdb_test "'$GDB_TOOL_DIR'gdb $binfile" "$gdb_prompt"
#gdb_test "up" "#\[0-9\]* *\[0-9xa-fH'\]* in .* \\(.*\\).*" "up in corefile.exp (reinit)"
gdb_test "up" "No stack." "up in corefile.exp (reinit)"

gdb_test "core" "No core file now."


# Test a run (start) command will clear any loaded core file.

gdb_test "core-file $corefile" "Core was generated by .*" "run: load core again"
gdb_test "info files" "Local core dump file:.*" "run: sanity check we see the core file"
send "\n" 
send "\n" 
send "\n" 

set test "run: with core"
if [runto_main] {
#    pass $test
} else {
    exit -1
}

set test "run: core file is cleared"
send "info files\n"
expect {
    -re "Local core dump file:.*" {
	send_user "fail $test"
    set GRET [exprt $GRET + 1]
    }
    -re "0" {
#	pass $test
    }
}
send "\n" 
send "\n" 
send "\n" 

set test "quit with a process"
gdb_test "quit" "A debugging session is active.*Quit anyway\\? \\(y or n\\)"
gdb_test "n" "Not confirmed\." "quit with processes: n"

gdb_exit

# Verify there is no question if only a core file is loaded.

gdb_test "'$GDB_TOOL_DIR'gdb" "$gdb_prompt"
gdb_test "core-file $corefile" "Core was generated by .*" "no question: load core"

set test "quit with a core file"
send "quit\n"
expect {
    -re "A debugging session is active.*Quit anyway\\? \\(y or n\\)" {
	send_user "fail $test"
    set GRET [expr $GRET + 1]
	gdb_test "n" {Not confirmed\.} "quit with processes: n"
    }
    eof {
#	pass $test
    }
}


# Test an attach command will clear any loaded core file.

#if ![is_remote target] {
#    set test "attach: spawn sleep"
#    set res [remote_spawn host "$binfile sleep"];
    set testpid 0
    send "./$binfile sleep & \n"
    expect {
        -timeout 2
        -re "\\\[1\\\] (\[0-9\]+).*$target_prompt" {
        set testpid $expect_out(1,string)
        }
        timeout {
        }
    }

    if { $testpid == 0 } {
        send "ps -ef | grep $binfile |grep -v \"grep $binfile\" \n"
        expect {
            -timeout 2
            -re " (\[0-9\]+).*$target_prompt" {
                set testpid $expect_out(1,string)
            }
            timeout {
                send_user "fail \n"
                set GRET [expr $GRET + 1]
            }
        }
    }
    # Avoid some race:
    sleep 2

    send_user "testpid = $testpid \n"
    # We don't care whether the program is still in the startup phase when we
    # attach.

    gdb_test "'$GDB_TOOL_DIR'gdb" "$gdb_prompt"

    gdb_test "core-file $corefile" "Core was generated by .*" "attach: load core again"
    gdb_test "info files" "Local core dump file:.*" "attach: sanity check we see the core file"
send "\n" 
send "\n" 
send "\n" 

    gdb_test "attach $testpid" "Attaching to process $testpid.*" "attach: with core"

    set test "attach: core file is cleared"
    send "info files\n"
    expect {
	-re "Local core dump file:.*$gdb_prompt" {
	    send_user "fail $test"
        set GRET [expr $GRET + 1]
	}
	-re "0" {
#	    pass $test
	}
    }

send "\n" 
send "\n" 
send "\n" 
    gdb_exit
#}
exit $GRET

interact
