#!/usr/bin/expect -f
# Copyright 2008-2012 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This tests the find command.

source ../lib/gdb_proc.exp
global GRET;
set GRET 0;
global ARGC;
global GDB_TOOL_DIR
set ARGC $argc             
global GDBPROMPT
global target_ip 
global  target_prompt 
set srcfile find.c

spawn ssh root@$target_ip

expect {
    -timeout 2
        -re "$target_prompt*" {
#            send_user "string key match while ssh $target_ip"
        }   
    timeout {
#        send_user "Please check string key while ssh $target_ip"
            set GRET [expr $GRET + 1]
    }   
}

gdb_test "cd /tmp/for_gdb_test/base_test" "$target_prompt*"
gdb_test "'$GDB_TOOL_DIR'gdb find" "$GDBPROMPT"

gdb_test "break $srcfile:stop_here" \
    "Breakpoint.*at.* file .*$srcfile, line.*" \
    "breakpoint function in file"
send "r\n"
expect {
    -timeout 2
    -re "Breakpoint \[0-9\]+,.*stop_here.* at .*$srcfile:.*$GDBPROMPT" {
    }
    timeout {
	send_user "\nrun until function breakpoint (timeout)\n"
            set GRET [expr $GRET + 1]
    }
}

# We've now got the target program in a state where we can test "find".

set hex_number {0x[0-9a-fA-F][0-9a-fA-F]*}
set history_prefix {[$][0-9]* = }
set newline "\[\r\n\]*"
set pattern_not_found "${newline}Pattern not found\[.\]"
set one_pattern_found "${newline}1 pattern found\[.\]"
set two_patterns_found "${newline}2 patterns found\[.\]"

# Test string pattern.

gdb_test "set *(int32_t*) &int8_search_buf\[10\] = 0x61616161" "$GDBPROMPT"

gdb_test "find &int8_search_buf\[0\], +sizeof(int8_search_buf), 'a', 'a', 'a'" \
    "${hex_number}.*<int8_search_buf\\+10>${newline}${hex_number}.*<int8_search_buf\\+11>${two_patterns_found}" \
    "find string pattern"

# Test not finding pattern because search range too small, with
# potential find at the edge of the range.

gdb_test "find &int8_search_buf\[0\], +10+3, \"aaaa\"" \
    "${pattern_not_found}" \
    "pattern not found at end of range"

# Increase the search range by 1 and we should find the pattern.

gdb_test "find &int8_search_buf\[0\], +10+3+1, 'a', 'a', 'a', 'a'" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "pattern found at end of range"

# Test max-count, $_ and $numfound.

gdb_test "find /1 &int8_search_buf\[0\], +sizeof(int8_search_buf), 'a', 'a', 'a'" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "max-count"

gdb_test "print \$_" \
    "${history_prefix}.*${hex_number}" \
    "\$_"

# 7.5gdb
#gdb_test "print \$_" \
#     "${history_prefix}.*${hex_number} <int8_search_buf\\+10>" \
#    "\$_"


gdb_test "print \$numfound" \
    "${history_prefix}1" \
    "\$numfound"

# Test max-count with size-char.
# They can be specified in either order.

gdb_test "find /1b &int8_search_buf\[0\], +sizeof(int8_search_buf), 0x61, 0x61, 0x61" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "size,max-count, /1b"

gdb_test "find /b1 &int8_search_buf\[0\], +sizeof(int8_search_buf), 0x61, 0x61, 0x61" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "size,max-count, /b1"

gdb_test "find /b /1 &int8_search_buf\[0\], +sizeof(int8_search_buf), 0x61, 0x61, 0x61" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "size,max-count, /b/1"

gdb_test "find /1 /b &int8_search_buf\[0\], +sizeof(int8_search_buf), 0x61, 0x61, 0x61" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "size,max-count, /1/b"

# Test specifying end address.

gdb_test "find /b &int8_search_buf\[0\], &int8_search_buf\[0\]+sizeof(int8_search_buf), 0x61, 0x61, 0x61, 0x61" \
    "${hex_number}.*<int8_search_buf\\+10>${one_pattern_found}" \
    "find byte pattern with end address"

# Test 16-bit pattern.

gdb_test "set int16_search_buf\[10\] = 0x1234" "$GDBPROMPT"

gdb_test "find /h &int16_search_buf\[0\], +sizeof(int16_search_buf), 0x1234" \
    "${hex_number}.*<int16_search_buf\\+20>${one_pattern_found}" \
    "find 16-bit pattern"

gdb_test "find &int16_search_buf\[0\], +sizeof(int16_search_buf), (int16_t) 0x1234" \
    "${hex_number}.*<int16_search_buf\\+20>${one_pattern_found}" \
    "find 16-bit pattern"

# Test 32-bit pattern.

gdb_test "set int32_search_buf\[10\] = 0x12345678" "$GDBPROMPT"

gdb_test "find &int32_search_buf\[0\], +sizeof(int32_search_buf), (int32_t) 0x12345678" \
    "${hex_number}.*<int32_search_buf\\+40>${one_pattern_found}" \
    "find 32-bit pattern"

gdb_test "find /w &int32_search_buf\[0\], +sizeof(int32_search_buf), 0x12345678" \
    "${hex_number}.*<int32_search_buf\\+40>${one_pattern_found}" \
    "find 32-bit pattern"

# Test 64-bit pattern.

gdb_test "set int64_search_buf\[10\] = 0xfedcba9876543210LL" "$GDBPROMPT"

gdb_test "find &int64_search_buf\[0\], +sizeof(int64_search_buf), (int64_t) 0xfedcba9876543210LL" \
    "${hex_number}.*<int64_search_buf\\+80>${one_pattern_found}" \
    "find 64-bit pattern"

gdb_test "find /g &int64_search_buf\[0\], +sizeof(int64_search_buf), 0xfedcba9876543210LL" \
    "${hex_number}.*<int64_search_buf\\+80>${one_pattern_found}" \
    "find 64-bit pattern"

# Test mixed-sized patterns.

gdb_test "set *(int8_t*) &search_buf\[10\] = 0x62" "$GDBPROMPT"
gdb_test "set *(int16_t*) &search_buf\[11\] = 0x6363" "$GDBPROMPT"
gdb_test "set *(int32_t*) &search_buf\[13\] = 0x64646464" "$GDBPROMPT"

gdb_test "find &search_buf\[0\], +100, (int8_t) 0x62, (int16_t) 0x6363, (int32_t) 0x64646464" \
    "${hex_number}${one_pattern_found}" \
    "find mixed-sized pattern"

# Test search spanning a large range, in the particular case of native
# targets, test the search spanning multiple chunks.
# Remote targets may implement the search differently.

set CHUNK_SIZE 16000 ;# see findcmd.c

gdb_test "set *(int32_t*) &search_buf\[0*${CHUNK_SIZE}+100\] = 0x12345678" "$GDBPROMPT"
gdb_test "set *(int32_t*) &search_buf\[1*${CHUNK_SIZE}+100\] = 0x12345678" "$GDBPROMPT"

gdb_test "find /w search_buf, +search_buf_size, 0x12345678" \
    "${hex_number}${newline}${hex_number}${two_patterns_found}" \
    "search spanning large range"

# For native targets, test a pattern straddling a chunk boundary.

#if [isnative] {
    gdb_test "set *(int32_t*) &search_buf\[${CHUNK_SIZE}-1\] = 0xfdb97531" "$GDBPROMPT"
    gdb_test "find /w search_buf, +search_buf_size, 0xfdb97531" \
    "${hex_number}${one_pattern_found}" \
    "find pattern straddling chunk boundary"
#}

# 7.5gdb

#gdb_test "find int64_search_buf, +64/8*100, int64_search_buf" " <int64_search_buf>.*1 pattern found\\."

exit $GRET

interact
